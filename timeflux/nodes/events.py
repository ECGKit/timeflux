"""Generate random events"""

import copy
import datetime
import json
import random
import string

import numpy as np
import pandas as pd

from timeflux.core.node import Node


class Events(Node):

    def __init__(self, rows_min=1, rows_max=10, string_min=3, string_max=12, items_min=0, items_max=5, seed=None):
        """Return random integers from value_min to value_max (inclusive)"""
        self._rows_min = rows_min
        self._rows_max = rows_max
        self._string_min = string_min
        self._string_max = string_max
        self._items_min = items_min
        self._items_max = items_max
        random.seed(seed)

    def random_string(self, length):
        return ''.join(random.choice(string.ascii_letters) for m in range(length))

    def update(self):
        rows = []
        for i in range(random.randint(self._rows_min, self._rows_max)):
            row = []
            row.append(self.random_string(random.randint(self._string_min, self._string_max)))
            data = {}
            for j in range(random.randint(self._items_min, self._items_max)):
                key = self.random_string(random.randint(self._string_min, self._string_max))
                value = self.random_string(random.randint(self._string_min, self._string_max))
                data[key] = value
            row.append(json.dumps(data))
            rows.append(row)
        self.o.set(rows, names=['label', 'data'])


class Periodic(Node):
    """Node that sends events at a regular interval.

    This node sends regular events after the first time the update method is
    called. If the update method is called at time `t`, and this node has a
    interval `ti` and phase `ts`, then the first event will be at `t + ts`.
    Then there will be one event at `t + ts + k ti` where `k` is 1, 2, ...

    Args:
        label (str): Event name that will be generated by this node.
        data (dict): Dictionary sent in each event.
        interval (dict): Dictionary with keyword arguments passed to
            `datetime.timedelta` to define the time interval between events.
            This can be seconds, milliseconds, microseconds, etc.
        phase (dict): Dictionary with keyword arguments passed to
            `datetime.timedelta` to define a phase for the stimulations. The
            first stimulation will happen after this time delta is observed.
            If not set, the phase will be as the interval.

    Attributes:
        o (Port): Default output, provides a pandas.DataFrame with events.

    Examples:

        The following YAML can be used to generate events every half second
        but only after 5 seconds have elapsed

        .. code-block:: yaml

           graphs:
              - nodes:
                - id: clock
                  module: timeflux.nodes.events
                  class: Periodic
                  params:
                    label: my-event-label
                    interval:
                      milliseconds: 500
                    phase:
                      seconds: 5

                - id: display
                  module: timeflux.nodes.debug
                  class: Display

                rate: 20

                edges:
                  - source: clock
                    target: display
    """

    def __init__(self, label='clock', data=None, interval=None, phase=None):
        super().__init__()

        interval = interval or {}
        phase = phase or interval
        delta_interval = datetime.timedelta(**interval)
        delta_phase = datetime.timedelta(**phase)
        if delta_interval.total_seconds() <= 0:
            raise ValueError('Periodic must have positive interval')
        if delta_phase.total_seconds() <= 0:
            raise ValueError('Periodic must have positive phase')

        self._period = np.timedelta64(delta_interval)
        self._phase = np.timedelta64(delta_phase)
        self._next_timestamp = None
        self._label = label
        self._data = data

    def update(self):
        now = np.datetime64(datetime.datetime.now())
        if self._next_timestamp is None:
            self._next_timestamp = now + self._phase
            self.logger.debug('Periodic will start sending events at %s',
                              self._next_timestamp)

        data = []
        times = []
        while self._next_timestamp < now:
            content = copy.deepcopy(self._data)
            data.append([self._label, content])
            times.append(self._next_timestamp)
            self._next_timestamp += self._period

        if data:
            self.logger.debug('Sending %d events', len(data))
            self.o.set(data, names=['label', 'data'], timestamps=times)

    def _set_next(self, reference):
        self._next_timestamp = reference + self._period


class ToSignal(Node):
    """ Extract meta from event and  convert in a signal
    Example:
    -------
    >>> events = tm.makeTimeDataFrame(5, freq='L').rename(columns={'A': 'label', 'B': 'data'})
    >>> labels = ['foo', 'bar', 'zaz', 'rer', 'foo']
    >>> data = [{'a': 1, 'b': 10}, {'a': 2, 'b': 20}, {}, {}, {'a': 1, 'c': 2},]
    >>> events.label = labels
    >>> events.data = data
    >>> events
                                label               data
        2000-01-01 00:00:00.000   foo  {'a': 1, 'b': 10}
        2000-01-01 00:00:00.001   bar  {'a': 2, 'b': 20}
        2000-01-01 00:00:00.002   zaz                 {}
        2000-01-01 00:00:00.003   rer                 {}
        2000-01-01 00:00:00.004   foo   {'a': 1, 'c': 2}
    >>> node = ToSignal(labels=['bar', 'foo'], meta_keys=['a', 'b'])
    >>> node.update()
    >>> node.o.data
                                label  a     b
        2000-01-01 00:00:00.001   bar  2  20.0
        2000-01-01 00:00:00.000   foo  1  10.0
        2000-01-01 00:00:00.004   foo  1   NaN
    """

    def __init__(self, meta_keys, labels=None, label_column='label', meta_column='data', drop_label=True):
        if isinstance(labels, str):
            labels = [labels]
        self._labels = labels
        if isinstance(meta_keys, str):
            meta_keys = [meta_keys]
        self._meta_keys = meta_keys
        self._label_column = label_column
        self._meta_column = meta_column
        self._drop_label = drop_label

    def update(self):
        if not self.i.ready():
            return
        self.o = self.i
        if self._labels is not None:
            idx = self.i.data[self._label_column].isin(self._labels)
            self.i.data = self.i.data.loc[idx]

        selected_meta = pd.DataFrame(index=self.i.data.index, columns=self._meta_keys)

        for meta_key in self._meta_keys:
            selected_meta[meta_key] = [a[meta_key] for a in self.i.data[self._meta_column].values]

        self.o.data = selected_meta

        if not self._drop_label:
            self.o.data = pd.concat([self.i.data[[self._label_column]], self.o.data], axis=1)
